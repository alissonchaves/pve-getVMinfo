<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Proxmox VM Inventory</title>
  <link rel="stylesheet" href="./css/bootstrap.min.css">
  <link rel="stylesheet" href="./css/custom.css">
</head>
<body>
  <div class="container py-4">
    <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2">
      <div>
        <h1 class="h3 mb-1">Proxmox VM Inventory</h1>
        <div class="meta" id="row-count"></div>
        <div class="legend">
          <span class="legend-item">Last Startup:</span>
          <span class="legend-item"><span class="legend-swatch row-old"></span>More than 1 year</span>
          <span class="legend-item"><span class="legend-swatch row-stale"></span>More than 6 months</span>
          <span class="legend-item"><span class="legend-swatch row-fresh"></span>Less than 6 months</span>
        </div>
      </div>
      <div class="toolbar">
        <div class="sort-controls">
          <select id="sort-column" class="form-select form-select-sm"></select>
          <select id="sort-order" class="form-select form-select-sm">
            <option value="asc">Ascending</option>
            <option value="desc">Descending</option>
          </select>
        </div>
        <button id="export-csv" class="btn btn-sm btn-secondary" type="button">Export filtered CSV</button>
        <button id="clear-filters" class="btn btn-sm btn-secondary" type="button">Clear filters</button>
      </div>
    </div>

    <div class="table-wrap">
      <div class="meta mb-2" id="generated-at"></div>
      <br>
      <input id="global-filter" class="form-control form-control-sm mb-3" type="text" placeholder="Search all columns">
      <div class="table-responsive">
        <table id="pve-table" class="table table-striped table-hover table-sm">
          <thead></thead>
          <tbody></tbody>
          <tfoot></tfoot>
        </table>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const csvUrl = './pve_inventory.csv';
      const table = document.getElementById('pve-table');
      const thead = table.createTHead();
      const tbody = table.tBodies[0];
      const tfoot = table.tFoot || table.createTFoot();
      const rowCount = document.getElementById('row-count');
      const generatedAt = document.getElementById('generated-at');
      const globalFilter = document.getElementById('global-filter');
      const clearBtn = document.getElementById('clear-filters');
      const exportBtn = document.getElementById('export-csv');
      const sortColumn = document.getElementById('sort-column');
      const sortOrder = document.getElementById('sort-order');
      let rows = [];
      let filters = [];
      let headerCells = [];
      let footerCells = [];
      let lastStartIndex = -1;
      let tagsIndex = -1;
      let vcpuIndex = -1;
      let memIndex = -1;
      let diskIndex = -1;
      let vmidIndex = -1;

      function parseCsv(text) {
        const result = [];
        let row = [];
        let cell = '';
        let inQuotes = false;

        for (let i = 0; i < text.length; i += 1) {
          const char = text[i];
          const next = text[i + 1];

          if (char === '"') {
            if (inQuotes && next === '"') {
              cell += '"';
              i += 1;
            } else {
              inQuotes = !inQuotes;
            }
            continue;
          }

          if (char === ',' && !inQuotes) {
            row.push(cell);
            cell = '';
            continue;
          }

          if ((char === '\n' || char === '\r') && !inQuotes) {
            if (cell.length || row.length) {
              row.push(cell);
              result.push(row);
              row = [];
              cell = '';
            }
            continue;
          }

          cell += char;
        }

        if (cell.length || row.length) {
          row.push(cell);
          result.push(row);
        }

        return result;
      }

      function dedupeRows(dataRows) {
        const seen = new Set();
        return dataRows.filter((row) => {
          const key = row.map((cell) => String(cell).trim()).join('\x1f');
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });
      }

      function buildTable(header, dataRows) {
        thead.innerHTML = '';
        tbody.innerHTML = '';
        tfoot.innerHTML = '';

        const headRow = thead.insertRow();
        header.forEach((col) => {
          const th = document.createElement('th');
          th.textContent = col;
          headRow.appendChild(th);
        });

        headerCells = Array.from(headRow.cells);
        const normalize = (value) => value.trim().toLowerCase().replace(/[_\s]+/g, '');
        lastStartIndex = headerCells.findIndex(
          (cell) => normalize(cell.textContent) === 'laststart'
        );
        tagsIndex = headerCells.findIndex(
          (cell) => normalize(cell.textContent) === 'tags'
        );
        vmidIndex = headerCells.findIndex(
          (cell) => normalize(cell.textContent) === 'vmid'
        );
        vcpuIndex = headerCells.findIndex(
          (cell) => normalize(cell.textContent) === 'vcpu'
        );
        memIndex = headerCells.findIndex(
          (cell) => normalize(cell.textContent).startsWith('mem')
        );
        diskIndex = headerCells.findIndex(
          (cell) => normalize(cell.textContent).startsWith('disk')
        );

        const filterRow = thead.insertRow();
        filterRow.className = 'filters';
        header.forEach((_, i) => {
          const th = document.createElement('th');
          const select = document.createElement('select');
          select.className = 'form-select form-select-sm col-filter';
          select.dataset.index = String(i);
          th.appendChild(select);
          filterRow.appendChild(th);
        });

        dataRows.forEach((row) => {
          const tr = tbody.insertRow();
          row.forEach((cell, idx) => {
            const td = tr.insertCell();
            if (idx === tagsIndex) {
              td.innerHTML = String(cell)
                .split(';')
                .map((part) => part.replace(/[&<>"]/g, (c) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;' }[c])))
                .join('<br>');
            } else if (idx === lastStartIndex) {
              const value = String(cell || '');
              td.dataset.raw = value;
              const parts = value.split('T');
              if (parts.length === 2) {
                td.innerHTML = `${parts[0]}<br>${parts[1]}`;
              } else {
                td.textContent = value;
              }
            } else {
              td.textContent = cell;
            }
          });
        });

        rows = Array.from(tbody.rows);
        filters = Array.from(document.querySelectorAll('.col-filter'));

        const footerRow = tfoot.insertRow();
        header.forEach((_, i) => {
          const td = footerRow.insertCell();
          td.textContent = i === 0 ? 'Totals' : '';
        });
        footerCells = Array.from(footerRow.cells);

        sortColumn.innerHTML = '';
        header.forEach((col, i) => {
          const opt = document.createElement('option');
          opt.value = String(i);
          opt.textContent = col;
          sortColumn.appendChild(opt);
        });
      }

      function getCellText(row, index) {
        return row.cells[index].textContent.trim();
      }

      function buildFilters() {
        filters.forEach((select) => {
          const index = Number(select.dataset.index);
          const values = new Set();
          rows.forEach((row) => values.add(getCellText(row, index)));
          const sorted = Array.from(values).sort((a, b) => a.localeCompare(b));

          select.innerHTML = '';
          const allOpt = document.createElement('option');
          allOpt.value = '';
          allOpt.textContent = 'All';
          select.appendChild(allOpt);

          if (index === lastStartIndex) {
            const options = [
              ['__age_old', 'More than 1 year'],
              ['__age_stale', '6 months to 1 year'],
              ['__age_fresh', 'Less than 6 months'],
            ];
            options.forEach(([value, label]) => {
              const opt = document.createElement('option');
              opt.value = value;
              opt.textContent = label;
              select.appendChild(opt);
            });
          }

          sorted.forEach((value) => {
            const opt = document.createElement('option');
            opt.value = value;
            opt.textContent = value || '-';
            select.appendChild(opt);
          });
        });
      }

      function updateRowStyles() {
        const statusIndex = headerCells.findIndex(
          (th) => th.textContent.trim().toLowerCase() === 'status'
        );
        if (statusIndex === -1) return;

        rows.forEach((row) => {
          const cell = row.cells[statusIndex];
          const value = cell.textContent.trim().toLowerCase();
          cell.classList.remove('status-online', 'status-offline');
          if (value === 'online') cell.classList.add('status-online');
          if (value === 'offline') cell.classList.add('status-offline');
        });

        if (lastStartIndex === -1) return;
        rows.forEach((row) => {
          row.classList.remove('row-old', 'row-stale', 'row-fresh');
          const bucket = getLastStartBucket(row);
          if (bucket === 'old') row.classList.add('row-old');
          if (bucket === 'stale') row.classList.add('row-stale');
          if (bucket === 'fresh') row.classList.add('row-fresh');
        });
      }

      function getLastStartBucket(row) {
        if (lastStartIndex === -1) return '';
        const now = new Date();
        const oneYearMs = 365 * 24 * 60 * 60 * 1000;
        const sixMonthsMs = 182 * 24 * 60 * 60 * 1000;
        const raw = row.cells[lastStartIndex]?.dataset?.raw;
        const value = raw ? raw.trim() : row.cells[lastStartIndex]?.textContent.trim();
        if (!value) return '';
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return '';
        const ageMs = now - date;
        if (ageMs > oneYearMs) return 'old';
        if (ageMs > sixMonthsMs) return 'stale';
        return 'fresh';
      }

      function compareValues(a, b, index) {
        const va = getCellText(a, index);
        const vb = getCellText(b, index);
        if (index === lastStartIndex) {
          const ra = a.cells[lastStartIndex]?.dataset?.raw || va;
          const rb = b.cells[lastStartIndex]?.dataset?.raw || vb;
          const da = new Date(ra);
          const db = new Date(rb);
          const ta = Number.isNaN(da.getTime()) ? 0 : da.getTime();
          const tb = Number.isNaN(db.getTime()) ? 0 : db.getTime();
          return ta - tb;
        }
        return va.localeCompare(vb, undefined, { numeric: true, sensitivity: 'base' });
      }

      function sortTable() {
        const index = Number(sortColumn.value || 0);
        const direction = sortOrder.value === 'desc' ? -1 : 1;
        const sorted = rows.slice().sort((a, b) => compareValues(a, b, index) * direction);
        sorted.forEach((row) => tbody.appendChild(row));
        rows = sorted;
        applyFilters();
      }

      function applyFilters() {
        const globalValue = globalFilter.value.trim().toLowerCase();
        let visibleCount = 0;
        let totalVcpu = 0;
        let totalMem = 0;
        let totalDisk = 0;

        rows.forEach((row) => {
          const cells = Array.from(row.cells).map((c) => c.textContent.trim());
          let visible = true;

          if (globalValue) {
            const matchAny = cells.some((v) => v.toLowerCase().includes(globalValue));
            if (!matchAny) visible = false;
          }

          filters.forEach((select, idx) => {
            if (!visible) return;
            const filterValue = select.value;
            if (!filterValue) return;
            if (idx === lastStartIndex && filterValue.startsWith('__age_')) {
              const bucket = getLastStartBucket(row);
              const wanted = filterValue.replace('__age_', '');
              if (bucket !== wanted) visible = false;
              return;
            }
            if (cells[idx] !== filterValue) visible = false;
          });

          row.style.display = visible ? '' : 'none';
          if (visible) {
            visibleCount += 1;
            if (vcpuIndex !== -1) {
              totalVcpu += Number(cells[vcpuIndex].replace(',', '.')) || 0;
            }
            if (memIndex !== -1) {
              totalMem += Number(cells[memIndex].replace(',', '.')) || 0;
            }
            if (diskIndex !== -1) {
              totalDisk += Number(cells[diskIndex].replace(',', '.')) || 0;
            }
          }
        });

        rowCount.textContent = '';
        if (footerCells.length) {
          footerCells.forEach((cell, idx) => {
            if (idx === 0) {
              cell.textContent = 'Totals:';
            } else if (idx === vmidIndex) {
              cell.textContent = String(visibleCount);
            } else if (idx === vcpuIndex) {
              cell.textContent = Math.round(totalVcpu).toString();
            } else if (idx === memIndex) {
              cell.textContent = totalMem.toFixed(1);
            } else if (idx === diskIndex) {
              cell.textContent = totalDisk.toFixed(1);
            } else {
              cell.textContent = '';
            }
          });
        }
      }

      function clearFilters() {
        filters.forEach((select) => {
          select.value = '';
        });
        globalFilter.value = '';
        applyFilters();
      }

      function csvEscape(value) {
        const text = String(value ?? '');
        if (/[",\n]/.test(text)) {
          return `"${text.replace(/"/g, '""')}"`;
        }
        return text;
      }

      function exportVisibleRows() {
        if (!headerCells.length) return;
        const header = headerCells.map((cell) => cell.textContent.trim());
        const lines = [header.map(csvEscape).join(',')];

        rows.forEach((row) => {
          if (row.style.display === 'none') return;
          const cells = Array.from(row.cells).map((c) => c.textContent.trim());
          lines.push(cells.map(csvEscape).join(','));
        });

        const blob = new Blob([lines.join('\n')], { type: 'text/csv;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'pve_inventory_filtered.csv';
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
      }

      function loadCsvText(text, lastModified) {
        const parsed = parseCsv(text);
        if (!parsed.length) throw new Error('CSV is empty');
        const header = parsed[0];
        const dataRows = dedupeRows(parsed.slice(1));
        const normalize = (value) => value.trim().toLowerCase().replace(/[_\s]+/g, '');
        const vmNameIndex = header.findIndex((col) => normalize(col) === 'vmname');
        const nodeIndex = header.findIndex((col) => normalize(col) === 'node');
        const statusIndex = header.findIndex((col) => normalize(col) === 'status');
        const poolIndex = header.findIndex((col) => normalize(col) === 'pool');
        let finalHeader = header;
        let finalRows = dataRows;

        const order = header.map((_, idx) => idx);

        if (vmNameIndex !== -1 && nodeIndex !== -1 && nodeIndex !== vmNameIndex + 1) {
          order.splice(order.indexOf(nodeIndex), 1);
          const insertAt = order.indexOf(vmNameIndex) + 1;
          order.splice(insertAt, 0, nodeIndex);
        }

        if (statusIndex !== -1 && poolIndex !== -1 && statusIndex < poolIndex) {
          const statusPos = order.indexOf(statusIndex);
          const poolPos = order.indexOf(poolIndex);
          if (statusPos !== -1 && poolPos !== -1 && statusPos < poolPos) {
            order.splice(poolPos, 1);
            order.splice(statusPos, 0, poolIndex);
          }
        }

        finalHeader = order.map((idx) => header[idx]);
        finalRows = dataRows.map((row) => order.map((idx) => row[idx]));

        buildTable(finalHeader, finalRows);
        if (lastStartIndex !== -1) {
          sortColumn.value = String(lastStartIndex);
          sortOrder.value = 'asc';
        }
        sortTable();
        buildFilters();
        updateRowStyles();
        applyFilters();
        if (lastModified) {
          generatedAt.textContent = `Generated at: ${lastModified}`;
        } else {
          generatedAt.textContent = `Generated at: ${new Date().toISOString()}`;
        }
      }

      function loadFromUrl(url) {
        fetch(url)
          .then((response) => {
            if (!response.ok) throw new Error('Failed to load CSV');
            const lastModified = response.headers.get('Last-Modified');
            return response.text().then((text) => ({ text, lastModified }));
          })
          .then((payload) => loadCsvText(payload.text, payload.lastModified))
          .catch((err) => {
            rowCount.textContent = 'Failed to load CSV';
            generatedAt.textContent = err.message;
          });
      }

      loadFromUrl(csvUrl);

      document.addEventListener('change', (event) => {
        if (event.target.classList.contains('col-filter')) applyFilters();
      });
      sortColumn.addEventListener('change', sortTable);
      sortOrder.addEventListener('change', sortTable);
      globalFilter.addEventListener('input', applyFilters);
      clearBtn.addEventListener('click', clearFilters);
      exportBtn.addEventListener('click', exportVisibleRows);
    })();
  </script>
</body>
</html>
